{"ast":null,"code":";\n(function (sax) {\n  sax.parser = function (strict, opt) {\n    return new SAXParser(strict, opt);\n  };\n  sax.SAXParser = SAXParser;\n  sax.SAXStream = SAXStream;\n  sax.createStream = createStream;\n  sax.MAX_BUFFER_LENGTH = 64 * 1024;\n  var buffers = [\"comment\", \"sgmlDecl\", \"textNode\", \"tagName\", \"doctype\", \"procInstName\", \"procInstBody\", \"entity\", \"attribName\", \"attribValue\", \"cdata\", \"script\"];\n  sax.EVENTS = [\"text\", \"processinginstruction\", \"sgmldeclaration\", \"doctype\", \"comment\", \"attribute\", \"opentag\", \"closetag\", \"opencdata\", \"cdata\", \"closecdata\", \"error\", \"end\", \"ready\", \"script\", \"opennamespace\", \"closenamespace\"];\n  function SAXParser(strict, opt) {\n    if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);\n    var parser = this;\n    clearBuffers(parser);\n    parser.q = parser.c = \"\";\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n    parser.opt = opt || {};\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n    parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n    parser.tags = [];\n    parser.closed = parser.closedRoot = parser.sawRoot = false;\n    parser.tag = parser.error = null;\n    parser.strict = !!strict;\n    parser.noscript = !!(strict || parser.opt.noscript);\n    parser.state = S.BEGIN;\n    parser.ENTITIES = Object.create(sax.ENTITIES);\n    parser.attribList = [];\n    if (parser.opt.xmlns) parser.ns = Object.create(rootNS);\n    parser.trackPosition = parser.opt.position !== false;\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0;\n    }\n    emit(parser, \"onready\");\n  }\n  if (!Object.create) Object.create = function (o) {\n    function f() {\n      this.__proto__ = o;\n    }\n    f.prototype = o;\n    return new f();\n  };\n  if (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {\n    return o.__proto__;\n  };\n  if (!Object.keys) Object.keys = function (o) {\n    var a = [];\n    for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n    return a;\n  };\n  function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10),\n      maxActual = 0;\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length;\n      if (len > maxAllowed) {\n        switch (buffers[i]) {\n          case \"textNode\":\n            closeText(parser);\n            break;\n          case \"cdata\":\n            emitNode(parser, \"oncdata\", parser.cdata);\n            parser.cdata = \"\";\n            break;\n          case \"script\":\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n            break;\n          default:\n            error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n        }\n      }\n      maxActual = Math.max(maxActual, len);\n    }\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH - maxActual + parser.position;\n  }\n  function clearBuffers(parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = \"\";\n    }\n  }\n  function flushBuffers(parser) {\n    closeText(parser);\n    if (parser.cdata !== \"\") {\n      emitNode(parser, \"oncdata\", parser.cdata);\n      parser.cdata = \"\";\n    }\n    if (parser.script !== \"\") {\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n  }\n  SAXParser.prototype = {\n    end: function end() {\n      _end(this);\n    },\n    write: write,\n    resume: function resume() {\n      this.error = null;\n      return this;\n    },\n    close: function close() {\n      return this.write(null);\n    },\n    flush: function flush() {\n      flushBuffers(this);\n    }\n  };\n  try {\n    var Stream = require(\"stream\").Stream;\n  } catch (ex) {\n    var Stream = function Stream() {};\n  }\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== \"error\" && ev !== \"end\";\n  });\n  function createStream(strict, opt) {\n    return new SAXStream(strict, opt);\n  }\n  function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);\n    Stream.apply(this);\n    this._parser = new SAXParser(strict, opt);\n    this.writable = true;\n    this.readable = true;\n    var me = this;\n    this._parser.onend = function () {\n      me.emit(\"end\");\n    };\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er);\n      me._parser.error = null;\n    };\n    this._decoder = null;\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev, {\n        get: function get() {\n          return me._parser[\"on\" + ev];\n        },\n        set: function set(h) {\n          if (!h) {\n            me.removeAllListeners(ev);\n            return me._parser[\"on\" + ev] = h;\n          }\n          me.on(ev, h);\n        },\n        enumerable: true,\n        configurable: false\n      });\n    });\n  }\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  });\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder;\n        this._decoder = new SD('utf8');\n      }\n      data = this._decoder.write(data);\n    }\n    this._parser.write(data.toString());\n    this.emit(\"data\", data);\n    return true;\n  };\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) this.write(chunk);\n    this._parser.end();\n    return true;\n  };\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this;\n    if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\" + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n    return Stream.prototype.on.call(me, ev, handler);\n  };\n  var whitespace = \"\\r\\n\\t \",\n    number = \"0124356789\",\n    letter = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n    quote = \"'\\\"\",\n    entity = number + letter + \"#\",\n    attribEnd = whitespace + \">\",\n    CDATA = \"[CDATA[\",\n    DOCTYPE = \"DOCTYPE\",\n    XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\",\n    XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\",\n    rootNS = {\n      xml: XML_NAMESPACE,\n      xmlns: XMLNS_NAMESPACE\n    };\n  whitespace = charClass(whitespace);\n  number = charClass(number);\n  letter = charClass(letter);\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040\\.\\d-]/;\n  quote = charClass(quote);\n  entity = charClass(entity);\n  attribEnd = charClass(attribEnd);\n  function charClass(str) {\n    return str.split(\"\").reduce(function (s, c) {\n      s[c] = true;\n      return s;\n    }, {});\n  }\n  function isRegExp(c) {\n    return Object.prototype.toString.call(c) === '[object RegExp]';\n  }\n  function is(charclass, c) {\n    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c];\n  }\n  function not(charclass, c) {\n    return !is(charclass, c);\n  }\n  var S = 0;\n  sax.STATE = {\n    BEGIN: S++,\n    TEXT: S++,\n    TEXT_ENTITY: S++,\n    OPEN_WAKA: S++,\n    SGML_DECL: S++,\n    SGML_DECL_QUOTED: S++,\n    DOCTYPE: S++,\n    DOCTYPE_QUOTED: S++,\n    DOCTYPE_DTD: S++,\n    DOCTYPE_DTD_QUOTED: S++,\n    COMMENT_STARTING: S++,\n    COMMENT: S++,\n    COMMENT_ENDING: S++,\n    COMMENT_ENDED: S++,\n    CDATA: S++,\n    CDATA_ENDING: S++,\n    CDATA_ENDING_2: S++,\n    PROC_INST: S++,\n    PROC_INST_BODY: S++,\n    PROC_INST_ENDING: S++,\n    OPEN_TAG: S++,\n    OPEN_TAG_SLASH: S++,\n    ATTRIB: S++,\n    ATTRIB_NAME: S++,\n    ATTRIB_NAME_SAW_WHITE: S++,\n    ATTRIB_VALUE: S++,\n    ATTRIB_VALUE_QUOTED: S++,\n    ATTRIB_VALUE_CLOSED: S++,\n    ATTRIB_VALUE_UNQUOTED: S++,\n    ATTRIB_VALUE_ENTITY_Q: S++,\n    ATTRIB_VALUE_ENTITY_U: S++,\n    CLOSE_TAG: S++,\n    CLOSE_TAG_SAW_WHITE: S++,\n    SCRIPT: S++,\n    SCRIPT_ENDING: S++\n  };\n  sax.ENTITIES = {\n    \"amp\": \"&\",\n    \"gt\": \">\",\n    \"lt\": \"<\",\n    \"quot\": \"\\\"\",\n    \"apos\": \"'\",\n    \"AElig\": 198,\n    \"Aacute\": 193,\n    \"Acirc\": 194,\n    \"Agrave\": 192,\n    \"Aring\": 197,\n    \"Atilde\": 195,\n    \"Auml\": 196,\n    \"Ccedil\": 199,\n    \"ETH\": 208,\n    \"Eacute\": 201,\n    \"Ecirc\": 202,\n    \"Egrave\": 200,\n    \"Euml\": 203,\n    \"Iacute\": 205,\n    \"Icirc\": 206,\n    \"Igrave\": 204,\n    \"Iuml\": 207,\n    \"Ntilde\": 209,\n    \"Oacute\": 211,\n    \"Ocirc\": 212,\n    \"Ograve\": 210,\n    \"Oslash\": 216,\n    \"Otilde\": 213,\n    \"Ouml\": 214,\n    \"THORN\": 222,\n    \"Uacute\": 218,\n    \"Ucirc\": 219,\n    \"Ugrave\": 217,\n    \"Uuml\": 220,\n    \"Yacute\": 221,\n    \"aacute\": 225,\n    \"acirc\": 226,\n    \"aelig\": 230,\n    \"agrave\": 224,\n    \"aring\": 229,\n    \"atilde\": 227,\n    \"auml\": 228,\n    \"ccedil\": 231,\n    \"eacute\": 233,\n    \"ecirc\": 234,\n    \"egrave\": 232,\n    \"eth\": 240,\n    \"euml\": 235,\n    \"iacute\": 237,\n    \"icirc\": 238,\n    \"igrave\": 236,\n    \"iuml\": 239,\n    \"ntilde\": 241,\n    \"oacute\": 243,\n    \"ocirc\": 244,\n    \"ograve\": 242,\n    \"oslash\": 248,\n    \"otilde\": 245,\n    \"ouml\": 246,\n    \"szlig\": 223,\n    \"thorn\": 254,\n    \"uacute\": 250,\n    \"ucirc\": 251,\n    \"ugrave\": 249,\n    \"uuml\": 252,\n    \"yacute\": 253,\n    \"yuml\": 255,\n    \"copy\": 169,\n    \"reg\": 174,\n    \"nbsp\": 160,\n    \"iexcl\": 161,\n    \"cent\": 162,\n    \"pound\": 163,\n    \"curren\": 164,\n    \"yen\": 165,\n    \"brvbar\": 166,\n    \"sect\": 167,\n    \"uml\": 168,\n    \"ordf\": 170,\n    \"laquo\": 171,\n    \"not\": 172,\n    \"shy\": 173,\n    \"macr\": 175,\n    \"deg\": 176,\n    \"plusmn\": 177,\n    \"sup1\": 185,\n    \"sup2\": 178,\n    \"sup3\": 179,\n    \"acute\": 180,\n    \"micro\": 181,\n    \"para\": 182,\n    \"middot\": 183,\n    \"cedil\": 184,\n    \"ordm\": 186,\n    \"raquo\": 187,\n    \"frac14\": 188,\n    \"frac12\": 189,\n    \"frac34\": 190,\n    \"iquest\": 191,\n    \"times\": 215,\n    \"divide\": 247,\n    \"OElig\": 338,\n    \"oelig\": 339,\n    \"Scaron\": 352,\n    \"scaron\": 353,\n    \"Yuml\": 376,\n    \"fnof\": 402,\n    \"circ\": 710,\n    \"tilde\": 732,\n    \"Alpha\": 913,\n    \"Beta\": 914,\n    \"Gamma\": 915,\n    \"Delta\": 916,\n    \"Epsilon\": 917,\n    \"Zeta\": 918,\n    \"Eta\": 919,\n    \"Theta\": 920,\n    \"Iota\": 921,\n    \"Kappa\": 922,\n    \"Lambda\": 923,\n    \"Mu\": 924,\n    \"Nu\": 925,\n    \"Xi\": 926,\n    \"Omicron\": 927,\n    \"Pi\": 928,\n    \"Rho\": 929,\n    \"Sigma\": 931,\n    \"Tau\": 932,\n    \"Upsilon\": 933,\n    \"Phi\": 934,\n    \"Chi\": 935,\n    \"Psi\": 936,\n    \"Omega\": 937,\n    \"alpha\": 945,\n    \"beta\": 946,\n    \"gamma\": 947,\n    \"delta\": 948,\n    \"epsilon\": 949,\n    \"zeta\": 950,\n    \"eta\": 951,\n    \"theta\": 952,\n    \"iota\": 953,\n    \"kappa\": 954,\n    \"lambda\": 955,\n    \"mu\": 956,\n    \"nu\": 957,\n    \"xi\": 958,\n    \"omicron\": 959,\n    \"pi\": 960,\n    \"rho\": 961,\n    \"sigmaf\": 962,\n    \"sigma\": 963,\n    \"tau\": 964,\n    \"upsilon\": 965,\n    \"phi\": 966,\n    \"chi\": 967,\n    \"psi\": 968,\n    \"omega\": 969,\n    \"thetasym\": 977,\n    \"upsih\": 978,\n    \"piv\": 982,\n    \"ensp\": 8194,\n    \"emsp\": 8195,\n    \"thinsp\": 8201,\n    \"zwnj\": 8204,\n    \"zwj\": 8205,\n    \"lrm\": 8206,\n    \"rlm\": 8207,\n    \"ndash\": 8211,\n    \"mdash\": 8212,\n    \"lsquo\": 8216,\n    \"rsquo\": 8217,\n    \"sbquo\": 8218,\n    \"ldquo\": 8220,\n    \"rdquo\": 8221,\n    \"bdquo\": 8222,\n    \"dagger\": 8224,\n    \"Dagger\": 8225,\n    \"bull\": 8226,\n    \"hellip\": 8230,\n    \"permil\": 8240,\n    \"prime\": 8242,\n    \"Prime\": 8243,\n    \"lsaquo\": 8249,\n    \"rsaquo\": 8250,\n    \"oline\": 8254,\n    \"frasl\": 8260,\n    \"euro\": 8364,\n    \"image\": 8465,\n    \"weierp\": 8472,\n    \"real\": 8476,\n    \"trade\": 8482,\n    \"alefsym\": 8501,\n    \"larr\": 8592,\n    \"uarr\": 8593,\n    \"rarr\": 8594,\n    \"darr\": 8595,\n    \"harr\": 8596,\n    \"crarr\": 8629,\n    \"lArr\": 8656,\n    \"uArr\": 8657,\n    \"rArr\": 8658,\n    \"dArr\": 8659,\n    \"hArr\": 8660,\n    \"forall\": 8704,\n    \"part\": 8706,\n    \"exist\": 8707,\n    \"empty\": 8709,\n    \"nabla\": 8711,\n    \"isin\": 8712,\n    \"notin\": 8713,\n    \"ni\": 8715,\n    \"prod\": 8719,\n    \"sum\": 8721,\n    \"minus\": 8722,\n    \"lowast\": 8727,\n    \"radic\": 8730,\n    \"prop\": 8733,\n    \"infin\": 8734,\n    \"ang\": 8736,\n    \"and\": 8743,\n    \"or\": 8744,\n    \"cap\": 8745,\n    \"cup\": 8746,\n    \"int\": 8747,\n    \"there4\": 8756,\n    \"sim\": 8764,\n    \"cong\": 8773,\n    \"asymp\": 8776,\n    \"ne\": 8800,\n    \"equiv\": 8801,\n    \"le\": 8804,\n    \"ge\": 8805,\n    \"sub\": 8834,\n    \"sup\": 8835,\n    \"nsub\": 8836,\n    \"sube\": 8838,\n    \"supe\": 8839,\n    \"oplus\": 8853,\n    \"otimes\": 8855,\n    \"perp\": 8869,\n    \"sdot\": 8901,\n    \"lceil\": 8968,\n    \"rceil\": 8969,\n    \"lfloor\": 8970,\n    \"rfloor\": 8971,\n    \"lang\": 9001,\n    \"rang\": 9002,\n    \"loz\": 9674,\n    \"spades\": 9824,\n    \"clubs\": 9827,\n    \"hearts\": 9829,\n    \"diams\": 9830\n  };\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key];\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e;\n    sax.ENTITIES[key] = s;\n  });\n  for (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S;\n  S = sax.STATE;\n  function emit(parser, event, data) {\n    parser[event] && parser[event](data);\n  }\n  function emitNode(parser, nodeType, data) {\n    if (parser.textNode) closeText(parser);\n    emit(parser, nodeType, data);\n  }\n  function closeText(parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode) emit(parser, \"ontext\", parser.textNode);\n    parser.textNode = \"\";\n  }\n  function textopts(opt, text) {\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n  function error(parser, er) {\n    closeText(parser);\n    if (parser.trackPosition) {\n      er += \"\\nLine: \" + parser.line + \"\\nColumn: \" + parser.column + \"\\nChar: \" + parser.c;\n    }\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n  function _end(parser) {\n    if (!parser.closedRoot) strictFail(parser, \"Unclosed root tag\");\n    if (parser.state !== S.BEGIN && parser.state !== S.TEXT) error(parser, \"Unexpected end\");\n    closeText(parser);\n    parser.c = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    SAXParser.call(parser, parser.strict, parser.opt);\n    return parser;\n  }\n  function strictFail(parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) throw new Error('bad call to strictFail');\n    if (parser.strict) error(parser, message);\n  }\n  function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n    var parent = parser.tags[parser.tags.length - 1] || parser,\n      tag = parser.tag = {\n        name: parser.tagName,\n        attributes: {}\n      };\n    if (parser.opt.xmlns) tag.ns = parent.ns;\n    parser.attribList.length = 0;\n  }\n  function qname(name, attribute) {\n    var i = name.indexOf(\":\"),\n      qualName = i < 0 ? [\"\", name] : name.split(\":\"),\n      prefix = qualName[0],\n      local = qualName[1];\n    if (attribute && name === \"xmlns\") {\n      prefix = \"xmlns\";\n      local = \"\";\n    }\n    return {\n      prefix: prefix,\n      local: local\n    };\n  }\n  function attrib(parser) {\n    if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]();\n    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      return parser.attribName = parser.attribValue = \"\";\n    }\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true),\n        prefix = qn.prefix,\n        local = qn.local;\n      if (prefix === \"xmlns\") {\n        if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser, \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n        } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser, \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n        } else {\n          var tag = parser.tag,\n            parent = parser.tags[parser.tags.length - 1] || parser;\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns);\n          }\n          tag.ns[local] = parser.attribValue;\n        }\n      }\n      parser.attribList.push([parser.attribName, parser.attribValue]);\n    } else {\n      parser.tag.attributes[parser.attribName] = parser.attribValue;\n      emitNode(parser, \"onattribute\", {\n        name: parser.attribName,\n        value: parser.attribValue\n      });\n    }\n    parser.attribName = parser.attribValue = \"\";\n  }\n  function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      var tag = parser.tag;\n      var qn = qname(parser.tagName);\n      tag.prefix = qn.prefix;\n      tag.local = qn.local;\n      tag.uri = tag.ns[qn.prefix] || \"\";\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n        tag.uri = qn.prefix;\n      }\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, \"onopennamespace\", {\n            prefix: p,\n            uri: tag.ns[p]\n          });\n        });\n      }\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i];\n        var name = nv[0],\n          value = nv[1],\n          qualName = qname(name, true),\n          prefix = qualName.prefix,\n          local = qualName.local,\n          uri = prefix == \"\" ? \"\" : tag.ns[prefix] || \"\",\n          a = {\n            name: name,\n            value: value,\n            prefix: prefix,\n            local: local,\n            uri: uri\n          };\n        if (prefix && prefix != \"xmlns\" && !uri) {\n          strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n          a.uri = prefix;\n        }\n        parser.tag.attributes[name] = a;\n        emitNode(parser, \"onattribute\", a);\n      }\n      parser.attribList.length = 0;\n    }\n    parser.tag.isSelfClosing = !!selfClosing;\n    parser.sawRoot = true;\n    parser.tags.push(parser.tag);\n    emitNode(parser, \"onopentag\", parser.tag);\n    if (!selfClosing) {\n      if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n        parser.state = S.SCRIPT;\n      } else {\n        parser.state = S.TEXT;\n      }\n      parser.tag = null;\n      parser.tagName = \"\";\n    }\n    parser.attribName = parser.attribValue = \"\";\n    parser.attribList.length = 0;\n  }\n  function closeTag(parser) {\n    if (!parser.tagName) {\n      strictFail(parser, \"Weird empty close tag.\");\n      parser.textNode += \"</>\";\n      parser.state = S.TEXT;\n      return;\n    }\n    if (parser.script) {\n      if (parser.tagName !== \"script\") {\n        parser.script += \"</\" + parser.tagName + \">\";\n        parser.tagName = \"\";\n        parser.state = S.SCRIPT;\n        return;\n      }\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n    var t = parser.tags.length;\n    var tagName = parser.tagName;\n    if (!parser.strict) tagName = tagName[parser.looseCase]();\n    var closeTo = tagName;\n    while (t--) {\n      var close = parser.tags[t];\n      if (close.name !== closeTo) {\n        strictFail(parser, \"Unexpected close tag\");\n      } else break;\n    }\n    if (t < 0) {\n      strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n      parser.textNode += \"</\" + parser.tagName + \">\";\n      parser.state = S.TEXT;\n      return;\n    }\n    parser.tagName = tagName;\n    var s = parser.tags.length;\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop();\n      parser.tagName = parser.tag.name;\n      emitNode(parser, \"onclosetag\", parser.tagName);\n      var x = {};\n      for (var i in tag.ns) x[i] = tag.ns[i];\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p];\n          emitNode(parser, \"onclosenamespace\", {\n            prefix: p,\n            uri: n\n          });\n        });\n      }\n    }\n    if (t === 0) parser.closedRoot = true;\n    parser.tagName = parser.attribValue = parser.attribName = \"\";\n    parser.attribList.length = 0;\n    parser.state = S.TEXT;\n  }\n  function parseEntity(parser) {\n    var entity = parser.entity,\n      entityLC = entity.toLowerCase(),\n      num,\n      numStr = \"\";\n    if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];\n    if (parser.ENTITIES[entityLC]) return parser.ENTITIES[entityLC];\n    entity = entityLC;\n    if (entity.charAt(0) === \"#\") {\n      if (entity.charAt(1) === \"x\") {\n        entity = entity.slice(2);\n        num = parseInt(entity, 16);\n        numStr = num.toString(16);\n      } else {\n        entity = entity.slice(1);\n        num = parseInt(entity, 10);\n        numStr = num.toString(10);\n      }\n    }\n    entity = entity.replace(/^0+/, \"\");\n    if (numStr.toLowerCase() !== entity) {\n      strictFail(parser, \"Invalid character entity\");\n      return \"&\" + parser.entity + \";\";\n    }\n    return String.fromCodePoint(num);\n  }\n  function write(chunk) {\n    var parser = this;\n    if (this.error) throw this.error;\n    if (parser.closed) return error(parser, \"Cannot write after close. Assign an onready handler.\");\n    if (chunk === null) return _end(parser);\n    var i = 0,\n      c = \"\";\n    while (parser.c = c = chunk.charAt(i++)) {\n      if (parser.trackPosition) {\n        parser.position++;\n        if (c === \"\\n\") {\n          parser.line++;\n          parser.column = 0;\n        } else parser.column++;\n      }\n      switch (parser.state) {\n        case S.BEGIN:\n          if (c === \"<\") {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n          } else if (not(whitespace, c)) {\n            strictFail(parser, \"Non-whitespace before first tag.\");\n            parser.textNode = c;\n            parser.state = S.TEXT;\n          }\n          continue;\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1;\n            while (c && c !== \"<\" && c !== \"&\") {\n              c = chunk.charAt(i++);\n              if (c && parser.trackPosition) {\n                parser.position++;\n                if (c === \"\\n\") {\n                  parser.line++;\n                  parser.column = 0;\n                } else parser.column++;\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1);\n          }\n          if (c === \"<\") {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n          } else {\n            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) strictFail(parser, \"Text data outside of root node.\");\n            if (c === \"&\") parser.state = S.TEXT_ENTITY;else parser.textNode += c;\n          }\n          continue;\n        case S.SCRIPT:\n          if (c === \"<\") {\n            parser.state = S.SCRIPT_ENDING;\n          } else parser.script += c;\n          continue;\n        case S.SCRIPT_ENDING:\n          if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n          } else {\n            parser.script += \"<\" + c;\n            parser.state = S.SCRIPT;\n          }\n          continue;\n        case S.OPEN_WAKA:\n          if (c === \"!\") {\n            parser.state = S.SGML_DECL;\n            parser.sgmlDecl = \"\";\n          } else if (is(whitespace, c)) {} else if (is(nameStart, c)) {\n            parser.state = S.OPEN_TAG;\n            parser.tagName = c;\n          } else if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n            parser.tagName = \"\";\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST;\n            parser.procInstName = parser.procInstBody = \"\";\n          } else {\n            strictFail(parser, \"Unencoded <\");\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition;\n              c = new Array(pad).join(\" \") + c;\n            }\n            parser.textNode += \"<\" + c;\n            parser.state = S.TEXT;\n          }\n          continue;\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, \"onopencdata\");\n            parser.state = S.CDATA;\n            parser.sgmlDecl = \"\";\n            parser.cdata = \"\";\n          } else if (parser.sgmlDecl + c === \"--\") {\n            parser.state = S.COMMENT;\n            parser.comment = \"\";\n            parser.sgmlDecl = \"\";\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE;\n            if (parser.doctype || parser.sawRoot) strictFail(parser, \"Inappropriately located doctype declaration\");\n            parser.doctype = \"\";\n            parser.sgmlDecl = \"\";\n          } else if (c === \">\") {\n            emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n            parser.sgmlDecl = \"\";\n            parser.state = S.TEXT;\n          } else if (is(quote, c)) {\n            parser.state = S.SGML_DECL_QUOTED;\n            parser.sgmlDecl += c;\n          } else parser.sgmlDecl += c;\n          continue;\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL;\n            parser.q = \"\";\n          }\n          parser.sgmlDecl += c;\n          continue;\n        case S.DOCTYPE:\n          if (c === \">\") {\n            parser.state = S.TEXT;\n            emitNode(parser, \"ondoctype\", parser.doctype);\n            parser.doctype = true;\n          } else {\n            parser.doctype += c;\n            if (c === \"[\") parser.state = S.DOCTYPE_DTD;else if (is(quote, c)) {\n              parser.state = S.DOCTYPE_QUOTED;\n              parser.q = c;\n            }\n          }\n          continue;\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c;\n          if (c === parser.q) {\n            parser.q = \"\";\n            parser.state = S.DOCTYPE;\n          }\n          continue;\n        case S.DOCTYPE_DTD:\n          parser.doctype += c;\n          if (c === \"]\") parser.state = S.DOCTYPE;else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED;\n            parser.q = c;\n          }\n          continue;\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c;\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD;\n            parser.q = \"\";\n          }\n          continue;\n        case S.COMMENT:\n          if (c === \"-\") parser.state = S.COMMENT_ENDING;else parser.comment += c;\n          continue;\n        case S.COMMENT_ENDING:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDED;\n            parser.comment = textopts(parser.opt, parser.comment);\n            if (parser.comment) emitNode(parser, \"oncomment\", parser.comment);\n            parser.comment = \"\";\n          } else {\n            parser.comment += \"-\" + c;\n            parser.state = S.COMMENT;\n          }\n          continue;\n        case S.COMMENT_ENDED:\n          if (c !== \">\") {\n            strictFail(parser, \"Malformed comment\");\n            parser.comment += \"--\" + c;\n            parser.state = S.COMMENT;\n          } else parser.state = S.TEXT;\n          continue;\n        case S.CDATA:\n          if (c === \"]\") parser.state = S.CDATA_ENDING;else parser.cdata += c;\n          continue;\n        case S.CDATA_ENDING:\n          if (c === \"]\") parser.state = S.CDATA_ENDING_2;else {\n            parser.cdata += \"]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n        case S.CDATA_ENDING_2:\n          if (c === \">\") {\n            if (parser.cdata) emitNode(parser, \"oncdata\", parser.cdata);\n            emitNode(parser, \"onclosecdata\");\n            parser.cdata = \"\";\n            parser.state = S.TEXT;\n          } else if (c === \"]\") {\n            parser.cdata += \"]\";\n          } else {\n            parser.cdata += \"]]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n        case S.PROC_INST:\n          if (c === \"?\") parser.state = S.PROC_INST_ENDING;else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY;else parser.procInstName += c;\n          continue;\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && is(whitespace, c)) continue;else if (c === \"?\") parser.state = S.PROC_INST_ENDING;else parser.procInstBody += c;\n          continue;\n        case S.PROC_INST_ENDING:\n          if (c === \">\") {\n            emitNode(parser, \"onprocessinginstruction\", {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            });\n            parser.procInstName = parser.procInstBody = \"\";\n            parser.state = S.TEXT;\n          } else {\n            parser.procInstBody += \"?\" + c;\n            parser.state = S.PROC_INST_BODY;\n          }\n          continue;\n        case S.OPEN_TAG:\n          if (is(nameBody, c)) parser.tagName += c;else {\n            newTag(parser);\n            if (c === \">\") openTag(parser);else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH;else {\n              if (not(whitespace, c)) strictFail(parser, \"Invalid character in tag name\");\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n        case S.OPEN_TAG_SLASH:\n          if (c === \">\") {\n            openTag(parser, true);\n            closeTag(parser);\n          } else {\n            strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n            parser.state = S.ATTRIB;\n          }\n          continue;\n        case S.ATTRIB:\n          if (is(whitespace, c)) continue;else if (c === \">\") openTag(parser);else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH;else if (is(nameStart, c)) {\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else strictFail(parser, \"Invalid attribute name\");\n          continue;\n        case S.ATTRIB_NAME:\n          if (c === \"=\") parser.state = S.ATTRIB_VALUE;else if (c === \">\") {\n            strictFail(parser, \"Attribute without value\");\n            parser.attribValue = parser.attribName;\n            attrib(parser);\n            openTag(parser);\n          } else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE;else if (is(nameBody, c)) parser.attribName += c;else strictFail(parser, \"Invalid attribute name\");\n          continue;\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === \"=\") parser.state = S.ATTRIB_VALUE;else if (is(whitespace, c)) continue;else {\n            strictFail(parser, \"Attribute without value\");\n            parser.tag.attributes[parser.attribName] = \"\";\n            parser.attribValue = \"\";\n            emitNode(parser, \"onattribute\", {\n              name: parser.attribName,\n              value: \"\"\n            });\n            parser.attribName = \"\";\n            if (c === \">\") openTag(parser);else if (is(nameStart, c)) {\n              parser.attribName = c;\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, \"Invalid attribute name\");\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n        case S.ATTRIB_VALUE:\n          if (is(whitespace, c)) continue;else if (is(quote, c)) {\n            parser.q = c;\n            parser.state = S.ATTRIB_VALUE_QUOTED;\n          } else {\n            strictFail(parser, \"Unquoted attribute value\");\n            parser.state = S.ATTRIB_VALUE_UNQUOTED;\n            parser.attribValue = c;\n          }\n          continue;\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_Q;else parser.attribValue += c;\n            continue;\n          }\n          attrib(parser);\n          parser.q = \"\";\n          parser.state = S.ATTRIB_VALUE_CLOSED;\n          continue;\n        case S.ATTRIB_VALUE_CLOSED:\n          if (is(whitespace, c)) {\n            parser.state = S.ATTRIB;\n          } else if (c === \">\") openTag(parser);else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH;else if (is(nameStart, c)) {\n            strictFail(parser, \"No whitespace between attributes\");\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else strictFail(parser, \"Invalid attribute name\");\n          continue;\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (not(attribEnd, c)) {\n            if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_U;else parser.attribValue += c;\n            continue;\n          }\n          attrib(parser);\n          if (c === \">\") openTag(parser);else parser.state = S.ATTRIB;\n          continue;\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (is(whitespace, c)) continue;else if (not(nameStart, c)) {\n              if (parser.script) {\n                parser.script += \"</\" + c;\n                parser.state = S.SCRIPT;\n              } else {\n                strictFail(parser, \"Invalid tagname in closing tag.\");\n              }\n            } else parser.tagName = c;\n          } else if (c === \">\") closeTag(parser);else if (is(nameBody, c)) parser.tagName += c;else if (parser.script) {\n            parser.script += \"</\" + parser.tagName;\n            parser.tagName = \"\";\n            parser.state = S.SCRIPT;\n          } else {\n            if (not(whitespace, c)) strictFail(parser, \"Invalid tagname in closing tag\");\n            parser.state = S.CLOSE_TAG_SAW_WHITE;\n          }\n          continue;\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (is(whitespace, c)) continue;\n          if (c === \">\") closeTag(parser);else strictFail(parser, \"Invalid characters in closing tag\");\n          continue;\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              var returnState = S.TEXT,\n                buffer = \"textNode\";\n              break;\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              var returnState = S.ATTRIB_VALUE_QUOTED,\n                buffer = \"attribValue\";\n              break;\n            case S.ATTRIB_VALUE_ENTITY_U:\n              var returnState = S.ATTRIB_VALUE_UNQUOTED,\n                buffer = \"attribValue\";\n              break;\n          }\n          if (c === \";\") {\n            parser[buffer] += parseEntity(parser);\n            parser.entity = \"\";\n            parser.state = returnState;\n          } else if (is(entity, c)) parser.entity += c;else {\n            strictFail(parser, \"Invalid character entity\");\n            parser[buffer] += \"&\" + parser.entity + c;\n            parser.entity = \"\";\n            parser.state = returnState;\n          }\n          continue;\n        default:\n          throw new Error(parser, \"Unknown state: \" + parser.state);\n      }\n    }\n    if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);\n    return parser;\n  }\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode;\n      var floor = Math.floor;\n      var fromCodePoint = function fromCodePoint() {\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = arguments.length;\n        if (!length) {\n          return '';\n        }\n        var result = '';\n        while (++index < length) {\n          var codePoint = Number(arguments[index]);\n          if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {\n            throw RangeError('Invalid code point: ' + codePoint);\n          }\n          if (codePoint <= 0xFFFF) {\n            codeUnits.push(codePoint);\n          } else {\n            codePoint -= 0x10000;\n            highSurrogate = (codePoint >> 10) + 0xD800;\n            lowSurrogate = codePoint % 0x400 + 0xDC00;\n            codeUnits.push(highSurrogate, lowSurrogate);\n          }\n          if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits);\n            codeUnits.length = 0;\n          }\n        }\n        return result;\n      };\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          'value': fromCodePoint,\n          'configurable': true,\n          'writable': true\n        });\n      } else {\n        String.fromCodePoint = fromCodePoint;\n      }\n    })();\n  }\n})(typeof exports === \"undefined\" ? sax = {} : exports);","map":{"version":3,"names":["sax","parser","strict","opt","SAXParser","SAXStream","createStream","MAX_BUFFER_LENGTH","buffers","EVENTS","clearBuffers","q","c","bufferCheckPosition","lowercase","lowercasetags","looseCase","tags","closed","closedRoot","sawRoot","tag","error","noscript","state","S","BEGIN","ENTITIES","Object","create","attribList","xmlns","ns","rootNS","trackPosition","position","line","column","emit","o","f","__proto__","prototype","getPrototypeOf","keys","a","i","hasOwnProperty","push","checkBufferLength","maxAllowed","Math","max","maxActual","l","length","len","closeText","emitNode","cdata","script","flushBuffers","end","write","resume","close","flush","Stream","require","ex","streamWraps","filter","ev","apply","_parser","writable","readable","me","onend","onerror","er","_decoder","forEach","defineProperty","get","set","h","removeAllListeners","on","enumerable","configurable","constructor","value","data","Buffer","isBuffer","SD","StringDecoder","toString","chunk","handler","indexOf","args","arguments","Array","splice","call","whitespace","number","letter","quote","entity","attribEnd","CDATA","DOCTYPE","XML_NAMESPACE","XMLNS_NAMESPACE","xml","charClass","nameStart","nameBody","str","split","reduce","s","isRegExp","is","charclass","match","not","STATE","TEXT","TEXT_ENTITY","OPEN_WAKA","SGML_DECL","SGML_DECL_QUOTED","DOCTYPE_QUOTED","DOCTYPE_DTD","DOCTYPE_DTD_QUOTED","COMMENT_STARTING","COMMENT","COMMENT_ENDING","COMMENT_ENDED","CDATA_ENDING","CDATA_ENDING_2","PROC_INST","PROC_INST_BODY","PROC_INST_ENDING","OPEN_TAG","OPEN_TAG_SLASH","ATTRIB","ATTRIB_NAME","ATTRIB_NAME_SAW_WHITE","ATTRIB_VALUE","ATTRIB_VALUE_QUOTED","ATTRIB_VALUE_CLOSED","ATTRIB_VALUE_UNQUOTED","ATTRIB_VALUE_ENTITY_Q","ATTRIB_VALUE_ENTITY_U","CLOSE_TAG","CLOSE_TAG_SAW_WHITE","SCRIPT","SCRIPT_ENDING","key","e","String","fromCharCode","event","nodeType","textNode","textopts","text","trim","normalize","replace","Error","strictFail","message","newTag","tagName","parent","name","attributes","qname","attribute","qualName","prefix","local","attrib","attribName","attribValue","qn","openTag","selfClosing","uri","JSON","stringify","p","nv","isSelfClosing","toLowerCase","closeTag","t","closeTo","pop","x","n","parseEntity","entityLC","num","numStr","charAt","slice","parseInt","fromCodePoint","startTagPosition","starti","substring","sgmlDecl","procInstName","procInstBody","pad","join","toUpperCase","comment","doctype","body","returnState","buffer","stringFromCharCode","floor","MAX_SIZE","codeUnits","highSurrogate","lowSurrogate","index","result","codePoint","Number","isFinite","RangeError","exports"],"sources":["/Users/sinmingyu/Desktop/front/node_modules/react-native-xml2js/node_modules/sax/lib/sax.js"],"sourcesContent":["// wrapper for non-node envs\n;(function (sax) {\n\nsax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\nsax.SAXParser = SAXParser\nsax.SAXStream = SAXStream\nsax.createStream = createStream\n\n// When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n// When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n// since that's the earliest that a buffer overrun could occur.  This way, checks are\n// as rare as required, but as often as necessary to ensure never crossing this bound.\n// Furthermore, buffers are only tested at most once per write(), so passing a very\n// large string into write() might have undesirable effects, but this is manageable by\n// the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n// edge case, result in creating at most one complete copy of the string passed in.\n// Set to Infinity to have unlimited buffers.\nsax.MAX_BUFFER_LENGTH = 64 * 1024\n\nvar buffers = [\n  \"comment\", \"sgmlDecl\", \"textNode\", \"tagName\", \"doctype\",\n  \"procInstName\", \"procInstBody\", \"entity\", \"attribName\",\n  \"attribValue\", \"cdata\", \"script\"\n]\n\nsax.EVENTS = // for discoverability.\n  [ \"text\"\n  , \"processinginstruction\"\n  , \"sgmldeclaration\"\n  , \"doctype\"\n  , \"comment\"\n  , \"attribute\"\n  , \"opentag\"\n  , \"closetag\"\n  , \"opencdata\"\n  , \"cdata\"\n  , \"closecdata\"\n  , \"error\"\n  , \"end\"\n  , \"ready\"\n  , \"script\"\n  , \"opennamespace\"\n  , \"closenamespace\"\n  ]\n\nfunction SAXParser (strict, opt) {\n  if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)\n\n  var parser = this\n  clearBuffers(parser)\n  parser.q = parser.c = \"\"\n  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n  parser.opt = opt || {}\n  parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n  parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\"\n  parser.tags = []\n  parser.closed = parser.closedRoot = parser.sawRoot = false\n  parser.tag = parser.error = null\n  parser.strict = !!strict\n  parser.noscript = !!(strict || parser.opt.noscript)\n  parser.state = S.BEGIN\n  parser.ENTITIES = Object.create(sax.ENTITIES)\n  parser.attribList = []\n\n  // namespaces form a prototype chain.\n  // it always points at the current tag,\n  // which protos to its parent tag.\n  if (parser.opt.xmlns) parser.ns = Object.create(rootNS)\n\n  // mostly just for error reporting\n  parser.trackPosition = parser.opt.position !== false\n  if (parser.trackPosition) {\n    parser.position = parser.line = parser.column = 0\n  }\n  emit(parser, \"onready\")\n}\n\nif (!Object.create) Object.create = function (o) {\n  function f () { this.__proto__ = o }\n  f.prototype = o\n  return new f\n}\n\nif (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {\n  return o.__proto__\n}\n\nif (!Object.keys) Object.keys = function (o) {\n  var a = []\n  for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n  return a\n}\n\nfunction checkBufferLength (parser) {\n  var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    , maxActual = 0\n  for (var i = 0, l = buffers.length; i < l; i ++) {\n    var len = parser[buffers[i]].length\n    if (len > maxAllowed) {\n      // Text/cdata nodes can get big, and since they're buffered,\n      // we can get here under normal conditions.\n      // Avoid issues by emitting the text node now,\n      // so at least it won't get any bigger.\n      switch (buffers[i]) {\n        case \"textNode\":\n          closeText(parser)\n        break\n\n        case \"cdata\":\n          emitNode(parser, \"oncdata\", parser.cdata)\n          parser.cdata = \"\"\n        break\n\n        case \"script\":\n          emitNode(parser, \"onscript\", parser.script)\n          parser.script = \"\"\n        break\n\n        default:\n          error(parser, \"Max buffer length exceeded: \"+buffers[i])\n      }\n    }\n    maxActual = Math.max(maxActual, len)\n  }\n  // schedule the next check for the earliest possible buffer overrun.\n  parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)\n                             + parser.position\n}\n\nfunction clearBuffers (parser) {\n  for (var i = 0, l = buffers.length; i < l; i ++) {\n    parser[buffers[i]] = \"\"\n  }\n}\n\nfunction flushBuffers (parser) {\n  closeText(parser)\n  if (parser.cdata !== \"\") {\n    emitNode(parser, \"oncdata\", parser.cdata)\n    parser.cdata = \"\"\n  }\n  if (parser.script !== \"\") {\n    emitNode(parser, \"onscript\", parser.script)\n    parser.script = \"\"\n  }\n}\n\nSAXParser.prototype =\n  { end: function () { end(this) }\n  , write: write\n  , resume: function () { this.error = null; return this }\n  , close: function () { return this.write(null) }\n  , flush: function () { flushBuffers(this) }\n  }\n\ntry {\n  var Stream = require(\"stream\").Stream\n} catch (ex) {\n  var Stream = function () {}\n}\n\n\nvar streamWraps = sax.EVENTS.filter(function (ev) {\n  return ev !== \"error\" && ev !== \"end\"\n})\n\nfunction createStream (strict, opt) {\n  return new SAXStream(strict, opt)\n}\n\nfunction SAXStream (strict, opt) {\n  if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)\n\n  Stream.apply(this)\n\n  this._parser = new SAXParser(strict, opt)\n  this.writable = true\n  this.readable = true\n\n\n  var me = this\n\n  this._parser.onend = function () {\n    me.emit(\"end\")\n  }\n\n  this._parser.onerror = function (er) {\n    me.emit(\"error\", er)\n\n    // if didn't throw, then means error was handled.\n    // go ahead and clear error, so we can write again.\n    me._parser.error = null\n  }\n\n  this._decoder = null;\n\n  streamWraps.forEach(function (ev) {\n    Object.defineProperty(me, \"on\" + ev, {\n      get: function () { return me._parser[\"on\" + ev] },\n      set: function (h) {\n        if (!h) {\n          me.removeAllListeners(ev)\n          return me._parser[\"on\"+ev] = h\n        }\n        me.on(ev, h)\n      },\n      enumerable: true,\n      configurable: false\n    })\n  })\n}\n\nSAXStream.prototype = Object.create(Stream.prototype,\n  { constructor: { value: SAXStream } })\n\nSAXStream.prototype.write = function (data) {\n  if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n    if (!this._decoder) {\n      var SD = require('string_decoder').StringDecoder\n      this._decoder = new SD('utf8')\n    }\n    data = this._decoder.write(data);\n  }\n\n  this._parser.write(data.toString())\n  this.emit(\"data\", data)\n  return true\n}\n\nSAXStream.prototype.end = function (chunk) {\n  if (chunk && chunk.length) this.write(chunk)\n  this._parser.end()\n  return true\n}\n\nSAXStream.prototype.on = function (ev, handler) {\n  var me = this\n  if (!me._parser[\"on\"+ev] && streamWraps.indexOf(ev) !== -1) {\n    me._parser[\"on\"+ev] = function () {\n      var args = arguments.length === 1 ? [arguments[0]]\n               : Array.apply(null, arguments)\n      args.splice(0, 0, ev)\n      me.emit.apply(me, args)\n    }\n  }\n\n  return Stream.prototype.on.call(me, ev, handler)\n}\n\n\n\n// character classes and tokens\nvar whitespace = \"\\r\\n\\t \"\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  , number = \"0124356789\"\n  , letter = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  // (Letter | \"_\" | \":\")\n  , quote = \"'\\\"\"\n  , entity = number+letter+\"#\"\n  , attribEnd = whitespace + \">\"\n  , CDATA = \"[CDATA[\"\n  , DOCTYPE = \"DOCTYPE\"\n  , XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\"\n  , XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\"\n  , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n// turn all the string character sets into character class objects.\nwhitespace = charClass(whitespace)\nnumber = charClass(number)\nletter = charClass(letter)\n\n// http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n// This implementation works on strings, a single character at a time\n// as such, it cannot ever support astral-plane characters (10000-EFFFF)\n// without a significant breaking change to either this  parser, or the\n// JavaScript language.  Implementation of an emoji-capable xml parser\n// is left as an exercise for the reader.\nvar nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\nvar nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040\\.\\d-]/\n\nquote = charClass(quote)\nentity = charClass(entity)\nattribEnd = charClass(attribEnd)\n\nfunction charClass (str) {\n  return str.split(\"\").reduce(function (s, c) {\n    s[c] = true\n    return s\n  }, {})\n}\n\nfunction isRegExp (c) {\n  return Object.prototype.toString.call(c) === '[object RegExp]'\n}\n\nfunction is (charclass, c) {\n  return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]\n}\n\nfunction not (charclass, c) {\n  return !is(charclass, c)\n}\n\nvar S = 0\nsax.STATE =\n{ BEGIN                     : S++\n, TEXT                      : S++ // general stuff\n, TEXT_ENTITY               : S++ // &amp and such.\n, OPEN_WAKA                 : S++ // <\n, SGML_DECL                 : S++ // <!BLARG\n, SGML_DECL_QUOTED          : S++ // <!BLARG foo \"bar\n, DOCTYPE                   : S++ // <!DOCTYPE\n, DOCTYPE_QUOTED            : S++ // <!DOCTYPE \"//blah\n, DOCTYPE_DTD               : S++ // <!DOCTYPE \"//blah\" [ ...\n, DOCTYPE_DTD_QUOTED        : S++ // <!DOCTYPE \"//blah\" [ \"foo\n, COMMENT_STARTING          : S++ // <!-\n, COMMENT                   : S++ // <!--\n, COMMENT_ENDING            : S++ // <!-- blah -\n, COMMENT_ENDED             : S++ // <!-- blah --\n, CDATA                     : S++ // <![CDATA[ something\n, CDATA_ENDING              : S++ // ]\n, CDATA_ENDING_2            : S++ // ]]\n, PROC_INST                 : S++ // <?hi\n, PROC_INST_BODY            : S++ // <?hi there\n, PROC_INST_ENDING          : S++ // <?hi \"there\" ?\n, OPEN_TAG                  : S++ // <strong\n, OPEN_TAG_SLASH            : S++ // <strong /\n, ATTRIB                    : S++ // <a\n, ATTRIB_NAME               : S++ // <a foo\n, ATTRIB_NAME_SAW_WHITE     : S++ // <a foo _\n, ATTRIB_VALUE              : S++ // <a foo=\n, ATTRIB_VALUE_QUOTED       : S++ // <a foo=\"bar\n, ATTRIB_VALUE_CLOSED       : S++ // <a foo=\"bar\"\n, ATTRIB_VALUE_UNQUOTED     : S++ // <a foo=bar\n, ATTRIB_VALUE_ENTITY_Q     : S++ // <foo bar=\"&quot;\"\n, ATTRIB_VALUE_ENTITY_U     : S++ // <foo bar=&quot;\n, CLOSE_TAG                 : S++ // </a\n, CLOSE_TAG_SAW_WHITE       : S++ // </a   >\n, SCRIPT                    : S++ // <script> ...\n, SCRIPT_ENDING             : S++ // <script> ... <\n}\n\nsax.ENTITIES =\n{ \"amp\" : \"&\"\n, \"gt\" : \">\"\n, \"lt\" : \"<\"\n, \"quot\" : \"\\\"\"\n, \"apos\" : \"'\"\n, \"AElig\" : 198\n, \"Aacute\" : 193\n, \"Acirc\" : 194\n, \"Agrave\" : 192\n, \"Aring\" : 197\n, \"Atilde\" : 195\n, \"Auml\" : 196\n, \"Ccedil\" : 199\n, \"ETH\" : 208\n, \"Eacute\" : 201\n, \"Ecirc\" : 202\n, \"Egrave\" : 200\n, \"Euml\" : 203\n, \"Iacute\" : 205\n, \"Icirc\" : 206\n, \"Igrave\" : 204\n, \"Iuml\" : 207\n, \"Ntilde\" : 209\n, \"Oacute\" : 211\n, \"Ocirc\" : 212\n, \"Ograve\" : 210\n, \"Oslash\" : 216\n, \"Otilde\" : 213\n, \"Ouml\" : 214\n, \"THORN\" : 222\n, \"Uacute\" : 218\n, \"Ucirc\" : 219\n, \"Ugrave\" : 217\n, \"Uuml\" : 220\n, \"Yacute\" : 221\n, \"aacute\" : 225\n, \"acirc\" : 226\n, \"aelig\" : 230\n, \"agrave\" : 224\n, \"aring\" : 229\n, \"atilde\" : 227\n, \"auml\" : 228\n, \"ccedil\" : 231\n, \"eacute\" : 233\n, \"ecirc\" : 234\n, \"egrave\" : 232\n, \"eth\" : 240\n, \"euml\" : 235\n, \"iacute\" : 237\n, \"icirc\" : 238\n, \"igrave\" : 236\n, \"iuml\" : 239\n, \"ntilde\" : 241\n, \"oacute\" : 243\n, \"ocirc\" : 244\n, \"ograve\" : 242\n, \"oslash\" : 248\n, \"otilde\" : 245\n, \"ouml\" : 246\n, \"szlig\" : 223\n, \"thorn\" : 254\n, \"uacute\" : 250\n, \"ucirc\" : 251\n, \"ugrave\" : 249\n, \"uuml\" : 252\n, \"yacute\" : 253\n, \"yuml\" : 255\n, \"copy\" : 169\n, \"reg\" : 174\n, \"nbsp\" : 160\n, \"iexcl\" : 161\n, \"cent\" : 162\n, \"pound\" : 163\n, \"curren\" : 164\n, \"yen\" : 165\n, \"brvbar\" : 166\n, \"sect\" : 167\n, \"uml\" : 168\n, \"ordf\" : 170\n, \"laquo\" : 171\n, \"not\" : 172\n, \"shy\" : 173\n, \"macr\" : 175\n, \"deg\" : 176\n, \"plusmn\" : 177\n, \"sup1\" : 185\n, \"sup2\" : 178\n, \"sup3\" : 179\n, \"acute\" : 180\n, \"micro\" : 181\n, \"para\" : 182\n, \"middot\" : 183\n, \"cedil\" : 184\n, \"ordm\" : 186\n, \"raquo\" : 187\n, \"frac14\" : 188\n, \"frac12\" : 189\n, \"frac34\" : 190\n, \"iquest\" : 191\n, \"times\" : 215\n, \"divide\" : 247\n, \"OElig\" : 338\n, \"oelig\" : 339\n, \"Scaron\" : 352\n, \"scaron\" : 353\n, \"Yuml\" : 376\n, \"fnof\" : 402\n, \"circ\" : 710\n, \"tilde\" : 732\n, \"Alpha\" : 913\n, \"Beta\" : 914\n, \"Gamma\" : 915\n, \"Delta\" : 916\n, \"Epsilon\" : 917\n, \"Zeta\" : 918\n, \"Eta\" : 919\n, \"Theta\" : 920\n, \"Iota\" : 921\n, \"Kappa\" : 922\n, \"Lambda\" : 923\n, \"Mu\" : 924\n, \"Nu\" : 925\n, \"Xi\" : 926\n, \"Omicron\" : 927\n, \"Pi\" : 928\n, \"Rho\" : 929\n, \"Sigma\" : 931\n, \"Tau\" : 932\n, \"Upsilon\" : 933\n, \"Phi\" : 934\n, \"Chi\" : 935\n, \"Psi\" : 936\n, \"Omega\" : 937\n, \"alpha\" : 945\n, \"beta\" : 946\n, \"gamma\" : 947\n, \"delta\" : 948\n, \"epsilon\" : 949\n, \"zeta\" : 950\n, \"eta\" : 951\n, \"theta\" : 952\n, \"iota\" : 953\n, \"kappa\" : 954\n, \"lambda\" : 955\n, \"mu\" : 956\n, \"nu\" : 957\n, \"xi\" : 958\n, \"omicron\" : 959\n, \"pi\" : 960\n, \"rho\" : 961\n, \"sigmaf\" : 962\n, \"sigma\" : 963\n, \"tau\" : 964\n, \"upsilon\" : 965\n, \"phi\" : 966\n, \"chi\" : 967\n, \"psi\" : 968\n, \"omega\" : 969\n, \"thetasym\" : 977\n, \"upsih\" : 978\n, \"piv\" : 982\n, \"ensp\" : 8194\n, \"emsp\" : 8195\n, \"thinsp\" : 8201\n, \"zwnj\" : 8204\n, \"zwj\" : 8205\n, \"lrm\" : 8206\n, \"rlm\" : 8207\n, \"ndash\" : 8211\n, \"mdash\" : 8212\n, \"lsquo\" : 8216\n, \"rsquo\" : 8217\n, \"sbquo\" : 8218\n, \"ldquo\" : 8220\n, \"rdquo\" : 8221\n, \"bdquo\" : 8222\n, \"dagger\" : 8224\n, \"Dagger\" : 8225\n, \"bull\" : 8226\n, \"hellip\" : 8230\n, \"permil\" : 8240\n, \"prime\" : 8242\n, \"Prime\" : 8243\n, \"lsaquo\" : 8249\n, \"rsaquo\" : 8250\n, \"oline\" : 8254\n, \"frasl\" : 8260\n, \"euro\" : 8364\n, \"image\" : 8465\n, \"weierp\" : 8472\n, \"real\" : 8476\n, \"trade\" : 8482\n, \"alefsym\" : 8501\n, \"larr\" : 8592\n, \"uarr\" : 8593\n, \"rarr\" : 8594\n, \"darr\" : 8595\n, \"harr\" : 8596\n, \"crarr\" : 8629\n, \"lArr\" : 8656\n, \"uArr\" : 8657\n, \"rArr\" : 8658\n, \"dArr\" : 8659\n, \"hArr\" : 8660\n, \"forall\" : 8704\n, \"part\" : 8706\n, \"exist\" : 8707\n, \"empty\" : 8709\n, \"nabla\" : 8711\n, \"isin\" : 8712\n, \"notin\" : 8713\n, \"ni\" : 8715\n, \"prod\" : 8719\n, \"sum\" : 8721\n, \"minus\" : 8722\n, \"lowast\" : 8727\n, \"radic\" : 8730\n, \"prop\" : 8733\n, \"infin\" : 8734\n, \"ang\" : 8736\n, \"and\" : 8743\n, \"or\" : 8744\n, \"cap\" : 8745\n, \"cup\" : 8746\n, \"int\" : 8747\n, \"there4\" : 8756\n, \"sim\" : 8764\n, \"cong\" : 8773\n, \"asymp\" : 8776\n, \"ne\" : 8800\n, \"equiv\" : 8801\n, \"le\" : 8804\n, \"ge\" : 8805\n, \"sub\" : 8834\n, \"sup\" : 8835\n, \"nsub\" : 8836\n, \"sube\" : 8838\n, \"supe\" : 8839\n, \"oplus\" : 8853\n, \"otimes\" : 8855\n, \"perp\" : 8869\n, \"sdot\" : 8901\n, \"lceil\" : 8968\n, \"rceil\" : 8969\n, \"lfloor\" : 8970\n, \"rfloor\" : 8971\n, \"lang\" : 9001\n, \"rang\" : 9002\n, \"loz\" : 9674\n, \"spades\" : 9824\n, \"clubs\" : 9827\n, \"hearts\" : 9829\n, \"diams\" : 9830\n}\n\nObject.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n})\n\nfor (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S\n\n// shorthand\nS = sax.STATE\n\nfunction emit (parser, event, data) {\n  parser[event] && parser[event](data)\n}\n\nfunction emitNode (parser, nodeType, data) {\n  if (parser.textNode) closeText(parser)\n  emit(parser, nodeType, data)\n}\n\nfunction closeText (parser) {\n  parser.textNode = textopts(parser.opt, parser.textNode)\n  if (parser.textNode) emit(parser, \"ontext\", parser.textNode)\n  parser.textNode = \"\"\n}\n\nfunction textopts (opt, text) {\n  if (opt.trim) text = text.trim()\n  if (opt.normalize) text = text.replace(/\\s+/g, \" \")\n  return text\n}\n\nfunction error (parser, er) {\n  closeText(parser)\n  if (parser.trackPosition) {\n    er += \"\\nLine: \"+parser.line+\n          \"\\nColumn: \"+parser.column+\n          \"\\nChar: \"+parser.c\n  }\n  er = new Error(er)\n  parser.error = er\n  emit(parser, \"onerror\", er)\n  return parser\n}\n\nfunction end (parser) {\n  if (!parser.closedRoot) strictFail(parser, \"Unclosed root tag\")\n  if ((parser.state !== S.BEGIN) && (parser.state !== S.TEXT)) error(parser, \"Unexpected end\")\n  closeText(parser)\n  parser.c = \"\"\n  parser.closed = true\n  emit(parser, \"onend\")\n  SAXParser.call(parser, parser.strict, parser.opt)\n  return parser\n}\n\nfunction strictFail (parser, message) {\n  if (typeof parser !== 'object' || !(parser instanceof SAXParser))\n    throw new Error('bad call to strictFail');\n  if (parser.strict) error(parser, message)\n}\n\nfunction newTag (parser) {\n  if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n  var parent = parser.tags[parser.tags.length - 1] || parser\n    , tag = parser.tag = { name : parser.tagName, attributes : {} }\n\n  // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n  if (parser.opt.xmlns) tag.ns = parent.ns\n  parser.attribList.length = 0\n}\n\nfunction qname (name, attribute) {\n  var i = name.indexOf(\":\")\n    , qualName = i < 0 ? [ \"\", name ] : name.split(\":\")\n    , prefix = qualName[0]\n    , local = qualName[1]\n\n  // <x \"xmlns\"=\"http://foo\">\n  if (attribute && name === \"xmlns\") {\n    prefix = \"xmlns\"\n    local = \"\"\n  }\n\n  return { prefix: prefix, local: local }\n}\n\nfunction attrib (parser) {\n  if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]()\n\n  if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n    return parser.attribName = parser.attribValue = \"\"\n  }\n\n  if (parser.opt.xmlns) {\n    var qn = qname(parser.attribName, true)\n      , prefix = qn.prefix\n      , local = qn.local\n\n    if (prefix === \"xmlns\") {\n      // namespace binding attribute; push the binding into scope\n      if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n        strictFail( parser\n                  , \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\n\"\n                  + \"Actual: \" + parser.attribValue )\n      } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n        strictFail( parser\n                  , \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\n\"\n                  + \"Actual: \" + parser.attribValue )\n      } else {\n        var tag = parser.tag\n          , parent = parser.tags[parser.tags.length - 1] || parser\n        if (tag.ns === parent.ns) {\n          tag.ns = Object.create(parent.ns)\n        }\n        tag.ns[local] = parser.attribValue\n      }\n    }\n\n    // defer onattribute events until all attributes have been seen\n    // so any new bindings can take effect; preserve attribute order\n    // so deferred events can be emitted in document order\n    parser.attribList.push([parser.attribName, parser.attribValue])\n  } else {\n    // in non-xmlns mode, we can emit the event right away\n    parser.tag.attributes[parser.attribName] = parser.attribValue\n    emitNode( parser\n            , \"onattribute\"\n            , { name: parser.attribName\n              , value: parser.attribValue } )\n  }\n\n  parser.attribName = parser.attribValue = \"\"\n}\n\nfunction openTag (parser, selfClosing) {\n  if (parser.opt.xmlns) {\n    // emit namespace binding events\n    var tag = parser.tag\n\n    // add namespace info to tag\n    var qn = qname(parser.tagName)\n    tag.prefix = qn.prefix\n    tag.local = qn.local\n    tag.uri = tag.ns[qn.prefix] || \"\"\n\n    if (tag.prefix && !tag.uri) {\n      strictFail(parser, \"Unbound namespace prefix: \"\n                       + JSON.stringify(parser.tagName))\n      tag.uri = qn.prefix\n    }\n\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    if (tag.ns && parent.ns !== tag.ns) {\n      Object.keys(tag.ns).forEach(function (p) {\n        emitNode( parser\n                , \"onopennamespace\"\n                , { prefix: p , uri: tag.ns[p] } )\n      })\n    }\n\n    // handle deferred onattribute events\n    // Note: do not apply default ns to attributes:\n    //   http://www.w3.org/TR/REC-xml-names/#defaulting\n    for (var i = 0, l = parser.attribList.length; i < l; i ++) {\n      var nv = parser.attribList[i]\n      var name = nv[0]\n        , value = nv[1]\n        , qualName = qname(name, true)\n        , prefix = qualName.prefix\n        , local = qualName.local\n        , uri = prefix == \"\" ? \"\" : (tag.ns[prefix] || \"\")\n        , a = { name: name\n              , value: value\n              , prefix: prefix\n              , local: local\n              , uri: uri\n              }\n\n      // if there's any attributes with an undefined namespace,\n      // then fail on them now.\n      if (prefix && prefix != \"xmlns\" && !uri) {\n        strictFail(parser, \"Unbound namespace prefix: \"\n                         + JSON.stringify(prefix))\n        a.uri = prefix\n      }\n      parser.tag.attributes[name] = a\n      emitNode(parser, \"onattribute\", a)\n    }\n    parser.attribList.length = 0\n  }\n\n  parser.tag.isSelfClosing = !!selfClosing\n\n  // process the tag\n  parser.sawRoot = true\n  parser.tags.push(parser.tag)\n  emitNode(parser, \"onopentag\", parser.tag)\n  if (!selfClosing) {\n    // special case for <script> in non-strict mode.\n    if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n      parser.state = S.SCRIPT\n    } else {\n      parser.state = S.TEXT\n    }\n    parser.tag = null\n    parser.tagName = \"\"\n  }\n  parser.attribName = parser.attribValue = \"\"\n  parser.attribList.length = 0\n}\n\nfunction closeTag (parser) {\n  if (!parser.tagName) {\n    strictFail(parser, \"Weird empty close tag.\")\n    parser.textNode += \"</>\"\n    parser.state = S.TEXT\n    return\n  }\n\n  if (parser.script) {\n    if (parser.tagName !== \"script\") {\n      parser.script += \"</\" + parser.tagName + \">\"\n      parser.tagName = \"\"\n      parser.state = S.SCRIPT\n      return\n    }\n    emitNode(parser, \"onscript\", parser.script)\n    parser.script = \"\"\n  }\n\n  // first make sure that the closing tag actually exists.\n  // <a><b></c></b></a> will close everything, otherwise.\n  var t = parser.tags.length\n  var tagName = parser.tagName\n  if (!parser.strict) tagName = tagName[parser.looseCase]()\n  var closeTo = tagName\n  while (t --) {\n    var close = parser.tags[t]\n    if (close.name !== closeTo) {\n      // fail the first time in strict mode\n      strictFail(parser, \"Unexpected close tag\")\n    } else break\n  }\n\n  // didn't find it.  we already failed for strict, so just abort.\n  if (t < 0) {\n    strictFail(parser, \"Unmatched closing tag: \"+parser.tagName)\n    parser.textNode += \"</\" + parser.tagName + \">\"\n    parser.state = S.TEXT\n    return\n  }\n  parser.tagName = tagName\n  var s = parser.tags.length\n  while (s --> t) {\n    var tag = parser.tag = parser.tags.pop()\n    parser.tagName = parser.tag.name\n    emitNode(parser, \"onclosetag\", parser.tagName)\n\n    var x = {}\n    for (var i in tag.ns) x[i] = tag.ns[i]\n\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    if (parser.opt.xmlns && tag.ns !== parent.ns) {\n      // remove namespace bindings introduced by tag\n      Object.keys(tag.ns).forEach(function (p) {\n        var n = tag.ns[p]\n        emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n })\n      })\n    }\n  }\n  if (t === 0) parser.closedRoot = true\n  parser.tagName = parser.attribValue = parser.attribName = \"\"\n  parser.attribList.length = 0\n  parser.state = S.TEXT\n}\n\nfunction parseEntity (parser) {\n  var entity = parser.entity\n    , entityLC = entity.toLowerCase()\n    , num\n    , numStr = \"\"\n  if (parser.ENTITIES[entity])\n    return parser.ENTITIES[entity]\n  if (parser.ENTITIES[entityLC])\n    return parser.ENTITIES[entityLC]\n  entity = entityLC\n  if (entity.charAt(0) === \"#\") {\n    if (entity.charAt(1) === \"x\") {\n      entity = entity.slice(2)\n      num = parseInt(entity, 16)\n      numStr = num.toString(16)\n    } else {\n      entity = entity.slice(1)\n      num = parseInt(entity, 10)\n      numStr = num.toString(10)\n    }\n  }\n  entity = entity.replace(/^0+/, \"\")\n  if (numStr.toLowerCase() !== entity) {\n    strictFail(parser, \"Invalid character entity\")\n    return \"&\"+parser.entity + \";\"\n  }\n\n  return String.fromCodePoint(num)\n}\n\nfunction write (chunk) {\n  var parser = this\n  if (this.error) throw this.error\n  if (parser.closed) return error(parser,\n    \"Cannot write after close. Assign an onready handler.\")\n  if (chunk === null) return end(parser)\n  var i = 0, c = \"\"\n  while (parser.c = c = chunk.charAt(i++)) {\n    if (parser.trackPosition) {\n      parser.position ++\n      if (c === \"\\n\") {\n        parser.line ++\n        parser.column = 0\n      } else parser.column ++\n    }\n    switch (parser.state) {\n\n      case S.BEGIN:\n        if (c === \"<\") {\n          parser.state = S.OPEN_WAKA\n          parser.startTagPosition = parser.position\n        } else if (not(whitespace,c)) {\n          // have to process this as a text node.\n          // weird, but happens.\n          strictFail(parser, \"Non-whitespace before first tag.\")\n          parser.textNode = c\n          parser.state = S.TEXT\n        }\n      continue\n\n      case S.TEXT:\n        if (parser.sawRoot && !parser.closedRoot) {\n          var starti = i-1\n          while (c && c!==\"<\" && c!==\"&\") {\n            c = chunk.charAt(i++)\n            if (c && parser.trackPosition) {\n              parser.position ++\n              if (c === \"\\n\") {\n                parser.line ++\n                parser.column = 0\n              } else parser.column ++\n            }\n          }\n          parser.textNode += chunk.substring(starti, i-1)\n        }\n        if (c === \"<\") {\n          parser.state = S.OPEN_WAKA\n          parser.startTagPosition = parser.position\n        } else {\n          if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))\n            strictFail(parser, \"Text data outside of root node.\")\n          if (c === \"&\") parser.state = S.TEXT_ENTITY\n          else parser.textNode += c\n        }\n      continue\n\n      case S.SCRIPT:\n        // only non-strict\n        if (c === \"<\") {\n          parser.state = S.SCRIPT_ENDING\n        } else parser.script += c\n      continue\n\n      case S.SCRIPT_ENDING:\n        if (c === \"/\") {\n          parser.state = S.CLOSE_TAG\n        } else {\n          parser.script += \"<\" + c\n          parser.state = S.SCRIPT\n        }\n      continue\n\n      case S.OPEN_WAKA:\n        // either a /, ?, !, or text is coming next.\n        if (c === \"!\") {\n          parser.state = S.SGML_DECL\n          parser.sgmlDecl = \"\"\n        } else if (is(whitespace, c)) {\n          // wait for it...\n        } else if (is(nameStart,c)) {\n          parser.state = S.OPEN_TAG\n          parser.tagName = c\n        } else if (c === \"/\") {\n          parser.state = S.CLOSE_TAG\n          parser.tagName = \"\"\n        } else if (c === \"?\") {\n          parser.state = S.PROC_INST\n          parser.procInstName = parser.procInstBody = \"\"\n        } else {\n          strictFail(parser, \"Unencoded <\")\n          // if there was some whitespace, then add that in.\n          if (parser.startTagPosition + 1 < parser.position) {\n            var pad = parser.position - parser.startTagPosition\n            c = new Array(pad).join(\" \") + c\n          }\n          parser.textNode += \"<\" + c\n          parser.state = S.TEXT\n        }\n      continue\n\n      case S.SGML_DECL:\n        if ((parser.sgmlDecl+c).toUpperCase() === CDATA) {\n          emitNode(parser, \"onopencdata\")\n          parser.state = S.CDATA\n          parser.sgmlDecl = \"\"\n          parser.cdata = \"\"\n        } else if (parser.sgmlDecl+c === \"--\") {\n          parser.state = S.COMMENT\n          parser.comment = \"\"\n          parser.sgmlDecl = \"\"\n        } else if ((parser.sgmlDecl+c).toUpperCase() === DOCTYPE) {\n          parser.state = S.DOCTYPE\n          if (parser.doctype || parser.sawRoot) strictFail(parser,\n            \"Inappropriately located doctype declaration\")\n          parser.doctype = \"\"\n          parser.sgmlDecl = \"\"\n        } else if (c === \">\") {\n          emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl)\n          parser.sgmlDecl = \"\"\n          parser.state = S.TEXT\n        } else if (is(quote, c)) {\n          parser.state = S.SGML_DECL_QUOTED\n          parser.sgmlDecl += c\n        } else parser.sgmlDecl += c\n      continue\n\n      case S.SGML_DECL_QUOTED:\n        if (c === parser.q) {\n          parser.state = S.SGML_DECL\n          parser.q = \"\"\n        }\n        parser.sgmlDecl += c\n      continue\n\n      case S.DOCTYPE:\n        if (c === \">\") {\n          parser.state = S.TEXT\n          emitNode(parser, \"ondoctype\", parser.doctype)\n          parser.doctype = true // just remember that we saw it.\n        } else {\n          parser.doctype += c\n          if (c === \"[\") parser.state = S.DOCTYPE_DTD\n          else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_QUOTED\n            parser.q = c\n          }\n        }\n      continue\n\n      case S.DOCTYPE_QUOTED:\n        parser.doctype += c\n        if (c === parser.q) {\n          parser.q = \"\"\n          parser.state = S.DOCTYPE\n        }\n      continue\n\n      case S.DOCTYPE_DTD:\n        parser.doctype += c\n        if (c === \"]\") parser.state = S.DOCTYPE\n        else if (is(quote,c)) {\n          parser.state = S.DOCTYPE_DTD_QUOTED\n          parser.q = c\n        }\n      continue\n\n      case S.DOCTYPE_DTD_QUOTED:\n        parser.doctype += c\n        if (c === parser.q) {\n          parser.state = S.DOCTYPE_DTD\n          parser.q = \"\"\n        }\n      continue\n\n      case S.COMMENT:\n        if (c === \"-\") parser.state = S.COMMENT_ENDING\n        else parser.comment += c\n      continue\n\n      case S.COMMENT_ENDING:\n        if (c === \"-\") {\n          parser.state = S.COMMENT_ENDED\n          parser.comment = textopts(parser.opt, parser.comment)\n          if (parser.comment) emitNode(parser, \"oncomment\", parser.comment)\n          parser.comment = \"\"\n        } else {\n          parser.comment += \"-\" + c\n          parser.state = S.COMMENT\n        }\n      continue\n\n      case S.COMMENT_ENDED:\n        if (c !== \">\") {\n          strictFail(parser, \"Malformed comment\")\n          // allow <!-- blah -- bloo --> in non-strict mode,\n          // which is a comment of \" blah -- bloo \"\n          parser.comment += \"--\" + c\n          parser.state = S.COMMENT\n        } else parser.state = S.TEXT\n      continue\n\n      case S.CDATA:\n        if (c === \"]\") parser.state = S.CDATA_ENDING\n        else parser.cdata += c\n      continue\n\n      case S.CDATA_ENDING:\n        if (c === \"]\") parser.state = S.CDATA_ENDING_2\n        else {\n          parser.cdata += \"]\" + c\n          parser.state = S.CDATA\n        }\n      continue\n\n      case S.CDATA_ENDING_2:\n        if (c === \">\") {\n          if (parser.cdata) emitNode(parser, \"oncdata\", parser.cdata)\n          emitNode(parser, \"onclosecdata\")\n          parser.cdata = \"\"\n          parser.state = S.TEXT\n        } else if (c === \"]\") {\n          parser.cdata += \"]\"\n        } else {\n          parser.cdata += \"]]\" + c\n          parser.state = S.CDATA\n        }\n      continue\n\n      case S.PROC_INST:\n        if (c === \"?\") parser.state = S.PROC_INST_ENDING\n        else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY\n        else parser.procInstName += c\n      continue\n\n      case S.PROC_INST_BODY:\n        if (!parser.procInstBody && is(whitespace, c)) continue\n        else if (c === \"?\") parser.state = S.PROC_INST_ENDING\n        else parser.procInstBody += c\n      continue\n\n      case S.PROC_INST_ENDING:\n        if (c === \">\") {\n          emitNode(parser, \"onprocessinginstruction\", {\n            name : parser.procInstName,\n            body : parser.procInstBody\n          })\n          parser.procInstName = parser.procInstBody = \"\"\n          parser.state = S.TEXT\n        } else {\n          parser.procInstBody += \"?\" + c\n          parser.state = S.PROC_INST_BODY\n        }\n      continue\n\n      case S.OPEN_TAG:\n        if (is(nameBody, c)) parser.tagName += c\n        else {\n          newTag(parser)\n          if (c === \">\") openTag(parser)\n          else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n          else {\n            if (not(whitespace, c)) strictFail(\n              parser, \"Invalid character in tag name\")\n            parser.state = S.ATTRIB\n          }\n        }\n      continue\n\n      case S.OPEN_TAG_SLASH:\n        if (c === \">\") {\n          openTag(parser, true)\n          closeTag(parser)\n        } else {\n          strictFail(parser, \"Forward-slash in opening tag not followed by >\")\n          parser.state = S.ATTRIB\n        }\n      continue\n\n      case S.ATTRIB:\n        // haven't read the attribute name yet.\n        if (is(whitespace, c)) continue\n        else if (c === \">\") openTag(parser)\n        else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n        else if (is(nameStart, c)) {\n          parser.attribName = c\n          parser.attribValue = \"\"\n          parser.state = S.ATTRIB_NAME\n        } else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_NAME:\n        if (c === \"=\") parser.state = S.ATTRIB_VALUE\n        else if (c === \">\") {\n          strictFail(parser, \"Attribute without value\")\n          parser.attribValue = parser.attribName\n          attrib(parser)\n          openTag(parser)\n        }\n        else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE\n        else if (is(nameBody, c)) parser.attribName += c\n        else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_NAME_SAW_WHITE:\n        if (c === \"=\") parser.state = S.ATTRIB_VALUE\n        else if (is(whitespace, c)) continue\n        else {\n          strictFail(parser, \"Attribute without value\")\n          parser.tag.attributes[parser.attribName] = \"\"\n          parser.attribValue = \"\"\n          emitNode(parser, \"onattribute\",\n                   { name : parser.attribName, value : \"\" })\n          parser.attribName = \"\"\n          if (c === \">\") openTag(parser)\n          else if (is(nameStart, c)) {\n            parser.attribName = c\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, \"Invalid attribute name\")\n            parser.state = S.ATTRIB\n          }\n        }\n      continue\n\n      case S.ATTRIB_VALUE:\n        if (is(whitespace, c)) continue\n        else if (is(quote, c)) {\n          parser.q = c\n          parser.state = S.ATTRIB_VALUE_QUOTED\n        } else {\n          strictFail(parser, \"Unquoted attribute value\")\n          parser.state = S.ATTRIB_VALUE_UNQUOTED\n          parser.attribValue = c\n        }\n      continue\n\n      case S.ATTRIB_VALUE_QUOTED:\n        if (c !== parser.q) {\n          if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_Q\n          else parser.attribValue += c\n          continue\n        }\n        attrib(parser)\n        parser.q = \"\"\n        parser.state = S.ATTRIB_VALUE_CLOSED\n      continue\n\n      case S.ATTRIB_VALUE_CLOSED:\n        if (is(whitespace, c)) {\n          parser.state = S.ATTRIB\n        } else if (c === \">\") openTag(parser)\n        else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n        else if (is(nameStart, c)) {\n          strictFail(parser, \"No whitespace between attributes\")\n          parser.attribName = c\n          parser.attribValue = \"\"\n          parser.state = S.ATTRIB_NAME\n        } else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_VALUE_UNQUOTED:\n        if (not(attribEnd,c)) {\n          if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_U\n          else parser.attribValue += c\n          continue\n        }\n        attrib(parser)\n        if (c === \">\") openTag(parser)\n        else parser.state = S.ATTRIB\n      continue\n\n      case S.CLOSE_TAG:\n        if (!parser.tagName) {\n          if (is(whitespace, c)) continue\n          else if (not(nameStart, c)) {\n            if (parser.script) {\n              parser.script += \"</\" + c\n              parser.state = S.SCRIPT\n            } else {\n              strictFail(parser, \"Invalid tagname in closing tag.\")\n            }\n          } else parser.tagName = c\n        }\n        else if (c === \">\") closeTag(parser)\n        else if (is(nameBody, c)) parser.tagName += c\n        else if (parser.script) {\n          parser.script += \"</\" + parser.tagName\n          parser.tagName = \"\"\n          parser.state = S.SCRIPT\n        } else {\n          if (not(whitespace, c)) strictFail(parser,\n            \"Invalid tagname in closing tag\")\n          parser.state = S.CLOSE_TAG_SAW_WHITE\n        }\n      continue\n\n      case S.CLOSE_TAG_SAW_WHITE:\n        if (is(whitespace, c)) continue\n        if (c === \">\") closeTag(parser)\n        else strictFail(parser, \"Invalid characters in closing tag\")\n      continue\n\n      case S.TEXT_ENTITY:\n      case S.ATTRIB_VALUE_ENTITY_Q:\n      case S.ATTRIB_VALUE_ENTITY_U:\n        switch(parser.state) {\n          case S.TEXT_ENTITY:\n            var returnState = S.TEXT, buffer = \"textNode\"\n          break\n\n          case S.ATTRIB_VALUE_ENTITY_Q:\n            var returnState = S.ATTRIB_VALUE_QUOTED, buffer = \"attribValue\"\n          break\n\n          case S.ATTRIB_VALUE_ENTITY_U:\n            var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = \"attribValue\"\n          break\n        }\n        if (c === \";\") {\n          parser[buffer] += parseEntity(parser)\n          parser.entity = \"\"\n          parser.state = returnState\n        }\n        else if (is(entity, c)) parser.entity += c\n        else {\n          strictFail(parser, \"Invalid character entity\")\n          parser[buffer] += \"&\" + parser.entity + c\n          parser.entity = \"\"\n          parser.state = returnState\n        }\n      continue\n\n      default:\n        throw new Error(parser, \"Unknown state: \" + parser.state)\n    }\n  } // while\n  // cdata blocks can get very big under normal conditions. emit and move on.\n  // if (parser.state === S.CDATA && parser.cdata) {\n  //   emitNode(parser, \"oncdata\", parser.cdata)\n  //   parser.cdata = \"\"\n  // }\n  if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser)\n  return parser\n}\n\n/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\nif (!String.fromCodePoint) {\n        (function() {\n                var stringFromCharCode = String.fromCharCode;\n                var floor = Math.floor;\n                var fromCodePoint = function() {\n                        var MAX_SIZE = 0x4000;\n                        var codeUnits = [];\n                        var highSurrogate;\n                        var lowSurrogate;\n                        var index = -1;\n                        var length = arguments.length;\n                        if (!length) {\n                                return '';\n                        }\n                        var result = '';\n                        while (++index < length) {\n                                var codePoint = Number(arguments[index]);\n                                if (\n                                        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                                        codePoint < 0 || // not a valid Unicode code point\n                                        codePoint > 0x10FFFF || // not a valid Unicode code point\n                                        floor(codePoint) != codePoint // not an integer\n                                ) {\n                                        throw RangeError('Invalid code point: ' + codePoint);\n                                }\n                                if (codePoint <= 0xFFFF) { // BMP code point\n                                        codeUnits.push(codePoint);\n                                } else { // Astral code point; split in surrogate halves\n                                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                                        codePoint -= 0x10000;\n                                        highSurrogate = (codePoint >> 10) + 0xD800;\n                                        lowSurrogate = (codePoint % 0x400) + 0xDC00;\n                                        codeUnits.push(highSurrogate, lowSurrogate);\n                                }\n                                if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n                                        result += stringFromCharCode.apply(null, codeUnits);\n                                        codeUnits.length = 0;\n                                }\n                        }\n                        return result;\n                };\n                if (Object.defineProperty) {\n                        Object.defineProperty(String, 'fromCodePoint', {\n                                'value': fromCodePoint,\n                                'configurable': true,\n                                'writable': true\n                        });\n                } else {\n                        String.fromCodePoint = fromCodePoint;\n                }\n        }());\n}\n\n})(typeof exports === \"undefined\" ? sax = {} : exports);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}